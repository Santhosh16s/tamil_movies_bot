"""
родрооро┐ро┤рпН родро┐ро░рпИрокрпНрокроЯ рокро╛роЯрпН - родрпКро┤ро┐ро▓рпНроорпБро▒рпИ рокродро┐рокрпНрокрпБ
Professional Tamil Movie Bot with Enterprise-Grade Architecture

роЗродрпБ Telegram роорпВро▓роорпН 2025 HD родрооро┐ро┤рпН родро┐ро░рпИрокрпНрокроЯроЩрпНроХро│рпИ ро╡ро┤роЩрпНроХрпБроорпН рокро╛роЯрпНроЯро╛роХрпБроорпН.
Supabase Database рооро▒рпНро▒рпБроорпН fuzzy search-роР рокропройрпНрокроЯрпБродрпНродрпБроХро┐ро▒родрпБ.
"""

import os
import sys
import re
import time
import asyncio
import logging
import unicodedata
from functools import wraps
from datetime import datetime, timezone

import nest_asyncio
import telegram
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, Message
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
    ContextTypes,
)

from dotenv import load_dotenv
from rapidfuzz import process
from supabase.client import create_client, Client

# --- Apply nest_asyncio for running in nested loops (e.g., Jupyter, certain servers) ---
nest_asyncio.apply()

# --- Logging Configuration ---
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(funcName)s - %(message)s"
)
logger = logging.getLogger(__name__)

# --- Load Environment Variables ---
load_dotenv()

TOKEN: str = os.getenv("TOKEN")
if not TOKEN:
    logger.critical("тЭМ Telegram TOKEN not set in environment.")
    sys.exit(1)

ADMIN_IDS_STR: str = os.getenv("ADMIN_IDS", "")
admin_ids: set[int] = set(map(int, filter(None, ADMIN_IDS_STR.split(","))))

PRIVATE_CHANNEL_LINK: str = os.getenv("PRIVATE_CHANNEL_LINK", "")
SUPABASE_URL: str = os.getenv("SUPABASE_URL", "")
SUPABASE_KEY: str = os.getenv("SUPABASE_KEY", "")

# Group / Channel IDs
try:
    SKMOVIES_GROUP_ID: int = int(os.getenv("SKMOVIES_GROUP_ID"))
    SKMOVIESDISCUSSION_GROUP_ID: int = int(os.getenv("SKMOVIESDISCUSSION_GROUP_ID"))
    MOVIE_UPDATE_CHANNEL_ID: int = int(os.getenv("MOVIE_UPDATE_CHANNEL_ID"))
except Exception as e:
    logger.critical(f"тЭМ Invalid group/channel IDs: {e}")
    sys.exit(1)

MOVIE_UPDATE_CHANNEL_URL: str = PRIVATE_CHANNEL_LINK  # Reuse private channel link

# --- Supabase Client Initialization ---
try:
    supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)
    logger.info(f"тЬЕ Supabase client initialized: URL={SUPABASE_URL}, KEY={SUPABASE_KEY[:5]}***")
except Exception as e:
    logger.critical(f"тЭМ Supabase client initialization failed: {e}")
    sys.exit(1)

# --- Global State ---
user_files: dict[int, dict] = {}           # Temporary storage for /addmovie workflow
pending_file_requests: dict[int, dict] = {}  # Pending file requests per user
pending_post: dict[int, dict] = {}          # Pending /post messages per user
movies_data: dict[str, dict] = {}           # Cached movies from Supabase

logger.info("ЁЯЪА Initial configuration and environment loaded successfully.")

# =========================
# --- Section 2: Utilities & Helpers ---
# =========================

# --- родро┐ро░рпИроХрпНроХродрпИ рокрпЖропро░рпИ Extract роЪрпЖропрпНро╡родрпБ ---
def extract_title(filename: str) -> str:
    """
    роХрпЛрокрпНрокро┐ройрпН рокрпЖропро░ро┐ро▓ро┐ро░рпБроирпНродрпБ родро┐ро░рпИрокрпНрокроЯродрпНродро┐ройрпН родро▓рпИрокрпНрокрпИ роОроЯрпБроХрпНроХро┐ро▒родрпБ.
    """
    filename = re.sub(r"@\S+", "", filename)
    filename = re.sub(
        r"\b(480p|720p|1080p|x264|x265|HEVC|HDRip|WEBRip|AAC|10bit|DS4K|UNTOUCHED|mkv|mp4|HD|HQ|Tamil|Telugu|Hindi|English|Dubbed|Org|Original|Proper)\b",
        "", filename, flags=re.IGNORECASE
    )
    filename = re.sub(r"[\[\]\(\)\{\}]", " ", filename)
    filename = re.sub(r"\s+", " ", filename).strip()

    match = re.search(r"([a-zA-Z\s]+)(?:\(?)(20\d{2})(?:\)?)", filename)
    if match:
        return f"{match.group(1).strip()} ({match.group(2)})"

    # Fallback: Take first part before dash or number
    title = re.split(r"[-0-9]", filename)[0].strip()
    return title


# --- родро▓рпИрокрпНрокрпИ роЪрпБродрпНродрокрпНрокроЯрпБродрпНродрпБродро▓рпН ---
def clean_title(title: str) -> str:
    """
    Title-роР lowercase рооро▒рпНро▒рпБроорпН special characters роЗро▓рпНро▓ро╛рооро▓рпН рооро╛ро▒рпНро▒рпБроХро┐ро▒родрпБ.
    """
    cleaned = title.lower()
    cleaned = ''.join(c for c in cleaned if unicodedata.category(c)[0] not in ['S', 'C'])
    cleaned = re.sub(r'[^\w\s\(\)]', '', cleaned)
    cleaned = re.sub(r'\s+', ' ', cleaned).strip()
    return cleaned


# --- Supabase-роЗро▓ро┐ро░рпБроирпНродрпБ родро┐ро░рпИрокрпНрокроЯроЩрпНроХро│рпИ роПро▒рпНро▒рпБро╡родрпБ ---
def load_movies_data() -> dict[str, dict]:
    """
    Supabase-роЗро▓ро┐ро░рпБроирпНродрпБ роЕройрпИродрпНродрпБ родро┐ро░рпИрокрпНрокроЯроЩрпНроХро│рпИропрпБроорпН роПро▒рпНро▒ро┐роХрпН cache роЪрпЖропрпНропрпБроорпН.
    """
    try:
        response = supabase.table("movies").select("*").execute()
        movies = response.data or []
        movies_cache = {}

        for movie in movies:
            cleaned_title = clean_title(movie['title'])
            movies_cache[cleaned_title] = {
                'poster_url': movie['poster_url'],
                'files': {
                    '480p': movie['file_480p'],
                    '720p': movie['file_720p'],
                    '1080p': movie['file_1080p'],
                }
            }
        logger.info(f"тЬЕ {len(movies_cache)} родро┐ро░рпИрокрпНрокроЯроЩрпНроХро│рпН Supabase-роЗро▓ро┐ро░рпБроирпНродрпБ роПро▒рпНро▒рокрпНрокроЯрпНроЯрой.")
        return movies_cache
    except Exception as e:
        logger.error(f"тЭМ Supabase роЗро▓ро┐ро░рпБроирпНродрпБ родро┐ро░рпИрокрпНрокроЯродрпН родро░ро╡рпИрокрпН рокродро┐ро╡рпЗро▒рпНро▒ роорпБроЯро┐ропро╡ро┐ро▓рпНро▓рпИ: {e}")
        return {}


# --- Restricted decorator (Admin-only commands) ---
def restricted(func):
    """
    Admin-роороЯрпНроЯрпБроорпЗ роЗроирпНрод function-роР роЗропроХрпНроХ роЕройрпБроородро┐роХрпНроХро┐ро▒родрпБ.
    """
    @wraps(func)
    async def wrapped(update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
        user_id = update.effective_user.id
        if user_id not in admin_ids:
            await update.message.reply_text("тЭМ роЗроирпНрод command admins роороЯрпНроЯрпБроорпЗ рокропройрпНрокроЯрпБродрпНрод роорпБроЯро┐ропрпБроорпН")
            return
        return await func(update, context, *args, **kwargs)
    return wrapped


# --- роирпЗро░роорпН ро╡ро┐родрпНродро┐ропро╛роЪроорпН роХро╛роЯрпНроЯрпБроорпН роЙродро╡ро┐ ---
def time_diff(dt: datetime) -> str:
    """
    datetime роЗро░рпБроирпНродрпБ родро▒рпНрокрпЛродрпБ ро╡ро░рпИ ро╡ро┐родрпНродро┐ропро╛роЪродрпНродрпИ ро╡ро╛роЪроХрооро╛рой ро╡роЯро┐ро╡ро┐ро▓рпН роХро╛роЯрпНроЯрпБроХро┐ро▒родрпБ.
    """
    now = datetime.now(timezone.utc)
    diff = now - dt.replace(tzinfo=timezone.utc)
    seconds = int(diff.total_seconds())

    if seconds < 60:
        return f"{seconds} ро╡ро┐ройро╛роЯро┐роХро│рпН роорпБройрпНрокрпБ"
    minutes = seconds // 60
    if minutes < 60:
        return f"{minutes} роиро┐рооро┐роЯроЩрпНроХро│рпН роорпБройрпНрокрпБ"
    hours = minutes // 60
    if hours < 24:
        return f"{hours} роорогро┐роирпЗро░роорпН роорпБройрпНрокрпБ"
    days = hours // 24
    return f"{days} роиро╛роЯрпНроХро│рпН роорпБройрпНрокрпБ"


# --- 10 роиро┐рооро┐роЯроЩрпНроХро│ро┐ро▓рпН Message-роР delete роЪрпЖропрпНропрпБроорпН async function ---
async def delete_after_delay(context: ContextTypes.DEFAULT_TYPE, chat_id: int, message_id: int, delay: int = 600):
    """
    роХрпБро▒ро┐рокрпНрокро┐роЯрпНроЯ роХро╛ро▓родрпНродро┐ро▒рпНроХрпБрокрпН рокро┐ро▒роХрпБ Message-роР роирпАроХрпНроХрпБроорпН.
    Default: 600 seconds (10 роиро┐рооро┐роЯроЩрпНроХро│рпН)
    """
    await asyncio.sleep(delay)
    try:
        await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
        logger.info(f"Message {message_id} in chat {chat_id} deleted after {delay} seconds.")
    except Exception as e:
        logger.warning(f"Error deleting message {message_id} in chat {chat_id}: {e}")


# --- Fuzzy search helper ---
def fuzzy_search_movie(query: str, movies_list: list[str], threshold: int = 80, limit: int = 5) -> list[tuple[str, int]]:
    """
    RapidFuzz роорпВро▓роорпН search роЪрпЖропрпНроХро┐ро▒родрпБ, score_cutoff-роР рокропройрпНрокроЯрпБродрпНродро┐ relevant results родро░рпБроХро┐ро▒родрпБ.
    """
    return process.extract(query, movies_list, score_cutoff=threshold, limit=limit)
